# ~~大数条件判断后取余~~ 解法不对

## 题目描述

一个数x, x是十进制下的n位数 **0 <= n <= 1000**

1. 整数d, x是d的倍数 **0 <= d <= 1000**
2. x中不包含0和3

求有多少不同的n位数, 答案 mod 1000000007

## 分析

### 1. 为什么是1000000007

为什么要对1000000007取模大数阶乘，大数的排列组合等，一般都要求将输出结果对1000000007取模 为什么总是1000000007呢

1. 1000000007是一个质数
2. int32位的最大值为2147483647，所以对于int32位来说1000000007足够大
3. int64位的最大值为2^63-1，对于1000000007来说它的平方不会在int64中溢出 所以在大数相乘的时候，因为(a∗b)%c=((a%c)∗(b%c))%c，所以相乘时两边都对1000000007取模，再保存在int64里面不会溢出

### 2. 为什么取余, 跟大数有什么关系呢?

### 取余公式

取模有几个公式, 加减乘都行, 除数不行:

- (a + b) % c = ( ( a % c ) + ( b % c ) ) % c
- (a * b) % c = ( ( a % c ) * ( b % c ) ) % c
- (a – b) % c = ( ( a % c ) – ( b % c ) ) % c
- ~~(a / b ) % c = ( ( a % c ) / ( b % c ) ) % c~~

### 取模举例:

```
a = 145785635595363569532135132
b = 3151635135413512165131321321
c = 999874455222222200651351351
m = 1000000007
输出 (a*b*c)%m.

Method 1:
First multiply all the number and then take modulo:
(a*b*c)%m = (459405448184212290893339835148809
515332440033400818566717735644307024625348601572) % 
1000000007
a*b*c does not fit even in the unsigned long long 
int due to which system drop some of its most 
significant digits. Therefore, it gives wrong answer.
(a*b*c)%m = 798848767

Method 2:
Take modulo at each intermediate steps:
i = 1
i = (i*a) % m    // i = 508086243
i = (i*b) % m    // i = 144702857
i = (i*c) % m    // i = 798848767
i = 798848767 

Method 2 always gives correct answer.

来源: https://www.geeksforgeeks.org/modulo-1097-1000000007/
```

### 快速取模

#### 快速幂取模

快速幂取模就是在O(logn)内求出a^n mod b的值。算法的原理是ab mod c=(a mod c)(b mod c)mod c 

```java
long exp_mod(long a,long n,long b)
{
    long t;
    if(n == 0) return 1 % b;
    if(n == 1) return a % b;
    t = exp_mod(a, n / 2, b);
    t = t * t % b;
    if((n & 1) == 1) t = t * a % b;
    return t;
}
```

其中一个按位与运算:
> n & 1 表示n与1按位与, 这是二进制运算, 可以把n想象成二进制
> 如果按位与的结果是1, 跳出循环
    > 3 & 1
    >  011
    > &001
    >  001 结果是1
> 也就是说只有奇数满足条件


跟这个题有什么关系呢?

n是有1000位, 先看第二个条件, 排除包含0和3的数, 也就是每位数只有这几个数字

> ~~0~~ 1 2 ~~3~~ 4 5 6 7 8 9 这8个数, 每个位置有8种可能

也就是说, 全部数有10^n个, 排除0, 3, 一共有 `8 ^ n` 个数, 代入上边的函数后, 现在我们知道的结论是排除0和3后, 所有数的个数 mod 1000000007 后的值

### 3. d 倍数

经过上一步的计算, 我们现在要找**排除03后所有的种数的mod值**和**倍数**之间的关系

首先想到的是想到的是

```
排除03后的个数 = 倍数 * 最终符合条件的个数
```

再回看上边的取余公式: 
```
(a * b) % c = ( ( a % c ) * ( b % c ) ) % c
```

所以代入上面的公式

```
a = 倍数
b = 最终符合条件的个数
a * b = 排除03后的个数

(排除03后的个数) % c = ( ( 倍数 % c ) * ( 最终符合条件的个数 % c ) ) % c`
```

但是除法没有取模的公式怎么办:

```java
// c = 1000000007
// (a * b) % c = ( ( a % c ) * ( b % c ) ) % c
for (i = 1; i < 排除03后的个数%c; i++) {
    /*
    if ((排除03后的个数) % c == ( ( 倍数 % c ) * ( 最终符合条件的个数 % c ) ) % c) {
        最终符合条件的数
    }
    */
    // 可以完全使用计算后的模
    if (排除03后的个数的模 == ( (倍数%c) * (最终符合条件的个数 % c) ) % c) {
        rssult = 最终符合条件的个数 % c
    }
}
```
